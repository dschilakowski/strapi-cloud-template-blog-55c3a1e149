import { Common } from "@strapi/strapi";
import {
  BUTTON_DEFAULT_SETTING,
  DEFAULT_AS_SELECTABLE_VALUE,
  LINK_DEFAULT_SETTING,
  RICHTEXT_STORE_DEFAULT_SETTING,
  STORE_MODULE_UID,
  TYPOGRAPHY_H1_DEFAULT_SETTING,
  TYPOGRAPHY_H2_DEFAULT_SETTING,
  TYPOGRAPHY_H3_DEFAULT_SETTING,
  TYPOGRAPHY_H4_DEFAULT_SETTING,
  TYPOGRAPHY_H5_DEFAULT_SETTING,
  TYPOGRAPHY_H6_DEFAULT_SETTING,
  TYPOGRAPHY_P_DEFAULT_SETTING,
} from "../constants";
import { sleep } from "../utils/functions";
import pbEntityService from "./pbEntityService";

const { v4, validate } = require("uuid");

// Skipping vowels for short component & collection-type names.
// Note: This is suboptimal, however due to the limitation in characters
// for the moment our only solution to streamline shorter names.
const shortNameToNames = {
  // ContentElements:
  ccrds: "cards",
  ctwi: "textwithimage",
  cmltmd: "multimedia",
  chdln: "headline",
  cbttn: "button",
  crchtxt: "richtext",
  cccrdn: "accordion",
  ccrsl: "carousel",
  cfrm: "form",
  cgllry: "gallery",
  cmg: "image",
  cmgtckr: "image ticker",
  csprtr: "separator",
  cspcr: "spacer",
  csrchrslts: "searchresults",

  // General:
  crd: "card",

  // PaBu
  setting: "setting",
  str: "store",
  cesstr: "contentelementsettingsstore", // contentElementSettings
  glbl: "global",
  customcss: "customcss",

  // Global:
  rspnsvc: "responsiveconfig",
  lytc: "layoutconfig",
  ftrc: "footerconfig",
  nvgtnc: "navigationconfig",
  sc: "seoconfig",
  lgc: "logoconfig",
  frmsc: "formsconfig",
  srchc: "searchconfig",
  srchrsltsc: "searchresultsconfig",
  tgsc: "tagsconfig",
  mltlnggc: "multilanguageconfig",
  nmtnc: "animationconfig",
  scrllngc: "scrollingconfig",
  scrllttpc: "scrolltotopconfig",
  brdcrmbsc: "breadcrumbsconfig",

  // str Store:
  sclr: "color",
  sfnt: "font",
  sgglfnt: "googlefont",
  sspcx: "spaceX",
  sspcy: "spaceY",
  stypgrphy: "typography",
  sbttn: "button",
  slnk: "link",
  srchtxt: "richtext",
  sbckgrnd: "background",
  srrws: "arrows",

  // cesstr Store:
  cshdln: "headline",
  csbttn: "button",
  csrchtxt: "richtext",
  csccrdin: "accordion",
  cstwi: "text with image", // twi
  cscrds: "cards",
  cscrsl: "carousel",
  csfrm: "form",
  csgllry: "gallery",
  csmg: "image",
  csmgtckr: "image ticker",
  cssprtr: "separator",
  csspcr: "spacer",
  csmltmd: "multimedia",
  csccrdn: "accordion",
};

export default {
  /**
   * generateStoreEntryName
   * Store-Entries include a component with a custom strname and value(s).
   * This function combines these attributes together with the (readable)name of the component
   * and autogenerate a name that is then set as storeEntry.name and displayed in the relation
   * dropdowns.
   * @param {object} storeEntryData Lifecycle Data
   * @returns {Promise<string>} "componentName: component.strname value1 value2 ..."
   */
  async generateStoreEntryName(storeEntryData) {
    let autogeneratedName = "";
    if (storeEntryData && storeEntryData.setting && storeEntryData.setting[0]) {
      const storeSetting = await pbEntityService.findOne(
        `${storeEntryData.setting[0].__component}` as Common.UID.ContentType,
        storeEntryData.setting[0].id,
        {
          fields: ["*"],
        }
      )!;

      // Keep:
      console.log(
        `Map: ${storeEntryData.setting[0].__component} -> ${strapi
          .service("plugin::pabu.str")
          .readableLabel(
            storeEntryData.setting[0].__component.replace("pb.", "")
          )}`
      );

      autogeneratedName = `${strapi
        .service("plugin::pabu.str")
        .readableLabel(
          storeEntryData.setting[0].__component.replace("pb.", "")
        )}:${storeSetting?.strname ? ` ${storeSetting.strname}` : ""}`;

      if (storeSetting) {
        if (storeSetting.valueAttribute) {
          // SingleValue-Store-Entry:
          // The name of the attribute that contains the value is defined in valueAttribute.
          autogeneratedName += ` ${storeSetting[storeSetting.valueAttribute]}`;
        }
      }
    }

    return autogeneratedName;
  },

  /**
   * generateStoreEntryType
   * @param {object} storeEntryData Lifecycle Data
   * @returns {string} "componentName"
   */
  generateStoreEntryType(storeEntryData) {
    let autogeneratedType = strapi
      .service("plugin::pabu.str")
      .readableLabel(storeEntryData.setting[0].__component.replace("pb.", ""));

    // Add specialCases here:
    if (autogeneratedType === "googlefont") {
      // SpecialCase: googlefont shares type with font (sfnt).
      autogeneratedType = strapi
        .service("plugin::pabu.str")
        .readableLabel("sfnt");
    }
    return autogeneratedType;
  },

  /**
   * generateStoreEntryUUID
   * Skips generation if uuid exists.
   * // TODO:TBD: Do we want to generate a new uuid (import/export settings in mind?) on update?
   * @param {string} uuid
   * @returns {string} "1b8d6bcd-bbfd-9b2d-9b5d-ab9dfbbd4bod"
   */
  generateStoreEntryUUID(uuid) {
    const storeEntryUUID = uuid && validate(uuid) ? uuid : v4();
    return storeEntryUUID;
  },

  /**
   * readableLabel
   * @param {string} label "ccrds"
   * @returns {string} "cards"
   */
  readableLabel(label) {
    let readableLabel = label || "";
    readableLabel = shortNameToNames[label] ?? label;
    return readableLabel;
  },

  /**
   * validateAndReturnStoreValue
   * Validates the storeValue inside of storeRelation by checking if the attributeName
   * of the storeValue ("color" / "space") is a part of the storeAttribute ("spaceX" / "backgroundColorPrimary").
   *
   * @param {any} storeRelation {}
   * @param {string} storeAttribute "font"
   * @returns {any}
   */
  validateAndReturnStoreValue(storeRelation, storeAttribute) {
    let valueWasSanitized = false;
    let storeValue: unknown = null; // TODO: For the moment: color, spaceX, spaceY, font, googleFont.

    if (storeRelation && storeRelation.setting && storeRelation.setting[0]) {
      // ReadableName of the component.
      const nameOfComponent = strapi
        .service("plugin::pabu.str")
        .readableLabel(storeRelation.setting[0].__component.replace("pb.", ""));

      let valueAttribute = storeRelation.setting[0].valueAttribute;
      let couldMatch;
      // "Validation"
      // Store-Entry has attribute: valueAttribute
      // bgColor -> color || space -> spaceX || backgroundColor -> color (not matching: valueAttribute but matching nameOfComponent)
      if (
        valueAttribute &&
        (storeAttribute.toLowerCase().includes(valueAttribute.toLowerCase()) ||
          valueAttribute.toLowerCase().includes(storeAttribute.toLowerCase()) ||
          storeAttribute
            .toLowerCase()
            .includes(nameOfComponent.toLowerCase()) ||
          nameOfComponent.toLowerCase().includes(storeAttribute.toLowerCase()))
      ) {
        couldMatch = true;
        storeValue = storeRelation.setting[0][valueAttribute];
      } else {
        // "Validation"
        // Store-Entry has no attribute: valueAttribute
        // Possible multi value store-Entry
        if (
          storeAttribute
            .toLowerCase()
            .includes(nameOfComponent.toLowerCase()) ||
          nameOfComponent.toLowerCase().includes(storeAttribute.toLowerCase())
        ) {
          couldMatch = true;
          // Depending on further development this might include a bigger switch-statement here with different store-special-cases.
          if (
            storeRelation.setting[0].__component === "pb.sgglfnt" ||
            storeRelation.setting[0].__component === "pb.fnt"
          ) {
            // Streamlining of googlefont & font.
            // Only fontFamily & defaultLineHeight might be useful in NextJS.
            storeValue = {
              fontFamily: storeRelation.setting[0].fontName
                ? // font
                  `font-family: '${storeRelation.setting[0].fontName}'`
                : // googleFont
                  storeRelation.setting[0].googleFontFamily,
              defaultLineHeight: storeRelation.setting[0].defaultLineHeight,
            };
          } else {
            // Include all attributes of store-Entry.
            storeValue = storeRelation.setting[0];
          }
        }
      }
      if (!couldMatch) {
        console.log(
          `validateAndReturnStoreValue: Could NOT match ${storeAttribute} with ${JSON.stringify(
            storeRelation.setting[0]
          )}.`
        );
        // We should not rely on storeValue: null if sanitized or not.
        valueWasSanitized = true;
      }
    }
    return { storeValue, valueWasSanitized };
  },

  /**
   * getStoreValues
   * @param {object} storeEntryData Lifecycle Data
   * @returns {Promise<any>}
   */
  async getStoreValues(storeEntryData) {
    // Get componentData.
    let componentData;
    if (
      storeEntryData &&
      storeEntryData.__pivot &&
      storeEntryData.__pivot.field &&
      storeEntryData.__pivot.component_type
    ) {
      componentData = await pbEntityService.findOne(
        `${storeEntryData.__pivot.component_type}` as Common.UID.ContentType,
        storeEntryData.id,
        {
          fields: ["*"],
          populate: "pb-deep",
        }
      );
    }

    // Gather attributes that use values from store.
    let storeAttributes = [];
    if (componentData) {
      if (
        strapi.components &&
        strapi.components[storeEntryData.__pivot.component_type]
      ) {
        for (const componentDataAttributes of Object.entries(
          strapi.components[storeEntryData.__pivot.component_type].attributes
        )) {
          if (
            componentDataAttributes[1] &&
            /* @ts-ignore */
            componentDataAttributes[1].target === "plugin::pabu.str" &&
            componentDataAttributes[1].type === "relation"
          ) {
            // TODO:
            /* @ts-ignore */
            storeAttributes.push(componentDataAttributes[0]);
          }
        }
      }
    }

    // Replace relations in componentData with actual storeValue.
    let sanitizedStoreAttributes = {};
    let flatComponentData = { ...componentData }; // top-level-copy
    for (const storeAttribute of storeAttributes) {
      if (componentData[storeAttribute]) {
        console.log(componentData[storeAttribute]);
        console.log(storeAttribute);
        const validatedStoreValue = strapi
          .service("plugin::pabu.str")
          .validateAndReturnStoreValue(
            componentData[storeAttribute],
            storeAttribute
          );
        flatComponentData[storeAttribute] = validatedStoreValue.storeValue;
        if (validatedStoreValue.valueWasSanitized) {
          // TODO:
          /* @ts-ignore */
          sanitizedStoreAttributes[storeAttribute] = null;
        }
      }
    }

    // Replace componentData-Relations with incorrect values with null.
    let sanitizedComponentData;
    if (Object.keys(sanitizedStoreAttributes).length > 0) {
      try {
        sanitizedComponentData = await pbEntityService.update(
          `${storeEntryData.__pivot.component_type}` as Common.UID.ContentType,
          componentData.id,
          {
            // Corrected componentData
            data: { ...componentData, ...sanitizedStoreAttributes },
          }
        );
        // updateAndReturnPopulated-Workaround:
        if (sanitizedComponentData) {
          sanitizedComponentData = {
            ...componentData,
            ...sanitizedStoreAttributes,
          };
        }
        console.log(
          `Replaced incorrect relations in ${storeEntryData.__pivot.component_type} (id: ${componentData.id}).`
        );
      } catch (error) {
        console.log(error);
      }
    }

    return {
      data: componentData,
      flatData: flatComponentData,
      sanitizedData: sanitizedComponentData,
    };
  },

  /**
   * updateStoreFonts:
   * Moves fontFiles & cleans fontDirectories.
   */
  async updateStoreFonts(data) {
    if (data.setting[0] && data.setting[0].__component === "pb.sfnt") {
      // TODO: TSd
      const storeFont: any | null = (await pbEntityService.findOneByQuery(
        STORE_MODULE_UID,
        {
          fields: ["*"],
          filters: {
            struuid: data.struuid,
          },
          sort: {},
          populate: "pb-deep",
        }
      )) as any;
      const fontName = storeFont.setting[0].fontName
        ? storeFont.setting[0].fontName
        : "Roboto"; // Roboto as fallback

      await strapi
        .service("plugin::pabu.fonts")
        .copyFontFile(fontName, storeFont.setting[0].fontFile);

      await strapi.service("plugin::pabu.fonts").cleanFonts();
    }
  },
  /**
   * getAllStoreEntriesOfType:
   * Returns all storeEntries by storeType (font , googlefont, color) by matching with
   * store.name (startswith: ${storeType}:)
   * @returns {Promise<Array<any>}
   */
  async getAllStoreEntriesOfType(storeType: string) {
    const storeEntries = await pbEntityService.findMany(STORE_MODULE_UID, {
      fields: ["*"],
      filters: {
        name: {
          $startsWith: `${storeType}:`,
        },
      },
      sort: {},
      populate: "pb-deep",
    });
    return storeEntries ? storeEntries : [];
  },

  /**
   * createDefaultStoreValues:
   * Creates store values if there are no entries in the store.
   */
  async createDefaultStoreValues() {
    let createdDefaultStoreValues = false;
    const storeEntries = await pbEntityService.findMany(STORE_MODULE_UID, {
      fields: ["*"],
      filters: {},
      sort: {},
      populate: "pb-deep",
    });

    if (storeEntries) {
      if (storeEntries.length === 0) {
        strapi.log.info("[plugin::pabu.str] Creating default store values...");
      }
      try {
        let defaultStrCreated = false;
        if (!doesStrTypeExist(storeEntries, "pb.sfnt")) {
          strapi.log.info(
            "[plugin::pabu.str] Roboto (default) font does not require a fontFile."
          );
          // Font: Roboto
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sfnt",
                  strname: "Roboto (default)",
                  fontName: "Roboto-Regular",
                  defaultLineHeight: "1.2",
                },
              ],
              struuid: "8eb790b7-18a1-45b0-a409-a62fe03fd850",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }
        if (
          !doesStrTypeExist(
            storeEntries,
            TYPOGRAPHY_P_DEFAULT_SETTING.__component
          )
        ) {
          // Typographys
          // Typography: p
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [TYPOGRAPHY_P_DEFAULT_SETTING],
              struuid: "a3a47bda-0bde-446c-bbda-780d3b8832bf",
            },
          });
          await sleep(250);
          // Typography: h1
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [TYPOGRAPHY_H1_DEFAULT_SETTING],
              struuid: "f9ae3b9f-ee64-43be-ae67-b3d4c8f122af",
            },
          });
          await sleep(250);
          // Typography: h2
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [TYPOGRAPHY_H2_DEFAULT_SETTING],
              struuid: "fe2ab5b4-de76-48ec-83e8-e6b170ba27a7",
            },
          });
          await sleep(250);
          // Testing:
          // Typography: h3
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [TYPOGRAPHY_H3_DEFAULT_SETTING],
              struuid: "e50ce259-6ea8-4067-89ad-f0cc8cf65bcc",
            },
          });
          await sleep(250);
          // Typography: h4
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [TYPOGRAPHY_H4_DEFAULT_SETTING],
              struuid: "4ba43ed4-4ff0-420d-b1da-7a1f6113a9c6",
            },
          });
          await sleep(250);
          // Typography: h5
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [TYPOGRAPHY_H5_DEFAULT_SETTING],
              struuid: "cc1f1e04-7f7e-4e95-958c-ddc4e77dddfa",
            },
          });
          await sleep(250);
          // Typography: h6
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [TYPOGRAPHY_H6_DEFAULT_SETTING],
              struuid: "9c0c1da1-b9eb-4557-94d1-40593c234aa7",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }
        if (
          !doesStrTypeExist(storeEntries, BUTTON_DEFAULT_SETTING.__component)
        ) {
          // Typography: Button
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [BUTTON_DEFAULT_SETTING],
              struuid: "7f72878a-7b22-404c-8466-2f8cf114e06e",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }
        if (!doesStrTypeExist(storeEntries, LINK_DEFAULT_SETTING.__component)) {
          // Typography: Link
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [LINK_DEFAULT_SETTING],
              struuid: "f76da562-401a-45f0-815a-bc7bcded3d89",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }
        if (!doesStrTypeExist(storeEntries, "pb.sclr")) {
          // Colors
          // Color: Black
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sclr",
                  strname: "black",
                  color: "#000000",
                  valueAttribute: "color",
                },
              ],
              struuid: "b9af65ed-cb9a-4c62-953e-0e5ffdc85f4a",
            },
          });
          await sleep(250);
          // Color: White
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sclr",
                  strname: "white",
                  color: "#ffffff",
                  valueAttribute: "color",
                },
              ],
              struuid: "476c462a-3e41-47d2-8b2b-cfd0ae778dfb",
            },
          });
          await sleep(250);
          // Color: AM Yellow
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sclr",
                  strname: "yellow",
                  color: "#e8c312",
                  valueAttribute: "color",
                },
              ],
              struuid: "332ac61e-3692-4e6c-8a1f-602e73010be3",
            },
          });
          await sleep(250);
          // Color: AM Gray
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sclr",
                  strname: "gray",
                  color: "#5B6770",
                  valueAttribute: "color",
                },
              ],
              struuid: "bbc228f6-2edf-4789-a622-bef619e42971",
            },
          });
          await sleep(250);
          // Color: Transparent
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sclr",
                  strname: "transparent",
                  color: "#00000000",
                  valueAttribute: "color",
                },
              ],
              struuid: "37f74d3f-deb8-4eae-8846-536ec7194cba",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }
        if (!doesStrTypeExist(storeEntries, "pb.sspcx")) {
          // spaceX
          // spaceX: 0
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sspcx",
                  strname: "full width elements",
                  spaceX: 0,
                  valueAttribute: "spaceX",
                },
              ],
              struuid: "ad6cf07a-62cc-45a5-9b99-2c4333fa4d47",
            },
          });
          await sleep(250);
          // spaceX: 250
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sspcx",
                  strname: "indented elements",
                  spaceX: 250,
                  valueAttribute: "spaceX",
                },
              ],
              struuid: "95db7fe3-9d08-42e5-8fdf-d943180b30d8",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }
        if (!doesStrTypeExist(storeEntries, "pb.sspcy")) {
          // spaceY: 0
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sspcy",
                  strname: "no margin between elements",
                  spaceY: 0,
                  valueAttribute: "spaceY",
                },
              ],
              struuid: "762e5975-357d-4c5d-8bc1-5191bfe8cde6",
            },
          });
          await sleep(250);
          // spaceY: 30
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [
                {
                  __component: "pb.sspcy",
                  strname: "normal margin between elements",
                  spaceY: 30,
                  valueAttribute: "spaceY",
                },
              ],
              struuid: "abc3d097-d8fd-4cb0-a97d-d48ad68ee393",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }

        // Add additional default-Settings above!
        // Make sure to add `skipLifecycle: true` to all default entries.

        if (
          !doesStrTypeExist(
            storeEntries,
            RICHTEXT_STORE_DEFAULT_SETTING.__component
          )
        ) {
          // richtext:
          await pbEntityService.create(STORE_MODULE_UID, {
            data: {
              // Make sure to add `skipLifecycle: true` to all default entries.
              skipLifecycle: true,
              setting: [RICHTEXT_STORE_DEFAULT_SETTING],
              struuid: "c87c922e-e0bc-4fb1-a8e6-b42be6cc5da7",
            },
          });
          defaultStrCreated = true;
          await sleep(250);
        }

        if (defaultStrCreated) {
          createdDefaultStoreValues = true;
        }
      } catch (error) {
        strapi.log.error(
          "[plugin::pabu.str] Could not create default store values.",
          error
        );
      }
    }
    return createdDefaultStoreValues;
  },

  /**
   * populateStoreData
   * @param data glblData
   * @param {Array} stores default: ["str", "cesstr"]
   * @returns populatedStoreData
   */
  async populateStoreData(data, stores: Array<any> = ["str", "cesstr"]) {
    if (!data) {
      return data;
    }

    let storeData = {};
    for (const store of stores) {
      const storeEntries = await pbEntityService.findMany(
        `plugin::pabu.${store}`,
        {
          fields: ["*"],
          filters: {},
          sort: {},
          populate: "pb-deep",
        }
      );
      storeData[store] = storeEntries;
    }

    const populateObjectWithStoreData = (object, optimizeData: boolean) => {
      for (const [attributeKey, attributeValue] of Object.entries(object)) {
        if (
          attributeValue &&
          /* @ts-ignore */
          attributeValue.store &&
          /* @ts-ignore */
          attributeValue.storeType
        ) {
          /* @ts-ignore */
          if (attributeValue.values) {
            let storeValuesData = {};
            /* @ts-ignore */
            for (const storeId of attributeValue.values) {
              /* @ts-ignore */
              let relatedStoreData = storeData[attributeValue.store].find(
                (storeData) => storeData.id === storeId
              );
              // TBD: For now default (0) data is null.
              storeValuesData[storeId] = relatedStoreData
                ? strapi
                    .service("plugin::pabu.str")
                    .getStoreData(relatedStoreData.setting[0], optimizeData)
                : null;

              // TODO: Log for testing.
              if (
                storeId !== DEFAULT_AS_SELECTABLE_VALUE &&
                !relatedStoreData
              ) {
                strapi.log.debug(
                  /* @ts-ignore */
                  `Store-Entry [store: ${attributeValue.store} id: ${storeId}] does not exist anymore. (deleted?)`
                );
              }

              // Nested Store
              if (storeValuesData[storeId]) {
                for (const [innerKey, innerValue] of Object.entries(
                  storeValuesData[storeId]
                )) {
                  /* @ts-ignore */
                  if (innerValue && innerValue.values) {
                    let innerStoreValuesData = {};
                    /* @ts-ignore */
                    for (const nestedStoreId of innerValue.values) {
                      let innerRelatedStoreData = storeData[
                        /* @ts-ignore */
                        innerValue.store
                      ].find((storeData) => storeData.id === nestedStoreId);
                      // TBD: For now default (0) data is null.
                      innerStoreValuesData[nestedStoreId] =
                        innerRelatedStoreData
                          ? strapi
                              .service("plugin::pabu.str")
                              .getStoreData(
                                innerRelatedStoreData.setting[0],
                                optimizeData
                              )
                          : null;
                      // TODO: Log for testing.
                      if (
                        nestedStoreId !== DEFAULT_AS_SELECTABLE_VALUE &&
                        !relatedStoreData
                      ) {
                        strapi.log.debug(
                          /* @ts-ignore */
                          `Store-Entry (nested in: ${storeId}) [store: ${innerValue.store} id: ${nestedStoreId}] does not exist anymore. (deleted?)`
                        );
                      }
                    }
                    // Keep for debugging:
                    // console.log(
                    //   `.${attributeKey}.data.${storeId}.${innerKey}.data added`
                    // );
                    storeValuesData[storeId][innerKey].data =
                      innerStoreValuesData;
                  }
                }
              }
            }
            // Keep for debugging:
            // console.log(`.${attributeKey}.data added`);
            object[attributeKey].data = storeValuesData;
          }
        }
      }
      return object;
    };

    if (Object.keys(storeData).length > 0) {
      if (Array.isArray(data)) {
        // Store-Collection-Type [cesstr]
        // Note: Because of development of cfgModal Dropdowns we decided to not optimize
        // .data of storeValues if they are singleValues.
        const optimizeData = false;
        for (let index = 0; index < data.length; index++) {
          if (data[index].setting[0]) {
            data[index].setting[0] = populateObjectWithStoreData(
              data[index].setting[0],
              optimizeData
            );
            // TBD:
            // data[index].setting[0] = Object.keys(populatedData)
            //   .sort()
            //   .reduce(function (obj, key) {
            //     obj[key] = populatedData[key];
            //     return obj;
            //   }, {});
          }
        }
      } else {
        // SingleType with Components. [glbl]
        // Note: This was set to false with usage of spaceX & more Relations in glbl. (like in cesstr)
        const optimizeData = false;
        for (const [key, value] of Object.entries(data)) {
          if (value) {
            data[key] = populateObjectWithStoreData(value, optimizeData);
            // TBD:
            // data[key] = Object.keys(populatedData)
            //   .sort()
            //   .reduce(function (obj, key) {
            //     obj[key] = populatedData[key];
            //     return obj;
            //   }, {});
          }
        }
      }
    }
    return data;
  },

  /**
   * reduceBackgroundJsonData
   * @param backgrounds
   * @returns backgrounds without image & css attributes.
   */
  reduceBackgroundJsonData(backgrounds) {
    if (!backgrounds || !Array.isArray(backgrounds)) {
      return [];
    }
    for (let index = 0; index < backgrounds.length; index++) {
      if (backgrounds[index].setting && backgrounds[index].setting[0]) {
        // TBD: Do we need the image in the cfgModal-Dropdown?
        delete backgrounds[index].setting[0].backgroundImage;
        delete backgrounds[index].setting[0].additionalCss;
        delete backgrounds[index].setting[0].additionalCssHover;
      }
      backgrounds[index] = strapi
        .service("plugin::pabu.settings")
        .removeDynamicZoneArrayStructure(backgrounds[index], "setting");
    }
    return backgrounds;
  },

  /**
   * getStoreData
   * @param storeSettingData .setting[0] of your storeEntry
   * @param optimizeData Boolean
   * @param storeType optional: "color" If provided and storeSettingData is a singleValueStore-Entry it gets checked.
   * @returns storeSettingData
   */
  getStoreData(storeSettingData, optimizeData: boolean, storeType = null) {
    // Note: optimizeData Because of development of cfgModal Dropdowns we decided to not optimize
    // .data of storeValues if they are singleValues.

    if (storeSettingData && optimizeData) {
      if (storeSettingData.valueAttribute) {
        // "Sanitizing" is possible:
        if (storeType) {
          if (storeSettingData.valueAttribute !== storeType) {
            // singleValueStore-Entry does not match requested storeType
            console.log(
              `storeType ${storeType} does not match with singleValueStoreEntry-Type: ${storeSettingData.valueAttribute}`
            );
            return null;
          }
          // singleValueStore-Entry matches requested storeType
        }
        // singleValue-Store-Entry without sanitizing.
        return storeSettingData[storeSettingData.valueAttribute];
      }

      // Remove only when optimizeData: true
      delete storeSettingData.id;
      delete storeSettingData.strname;
    }
    // Remove always:
    delete storeSettingData.strinfo;
    delete storeSettingData.__component;

    return storeSettingData;
  },

  async initializeStrListView() {
    const pluginStore = strapi.store({
      // Note: NOT strapi.config.environment!
      environment: "",
      type: "plugin",
      // Note: NOT -!
      name: "content_manager_configuration",
    });

    await pluginStore.set({
      key: "content_types::plugin::pabu.str",
      value: {
        uid: "plugin::pabu.str",
        settings: {
          bulkable: true,
          filterable: true,
          searchable: true,
          pageSize: 50,
          mainField: "name",
          defaultSortBy: "type",
          defaultSortOrder: "ASC",
        },
        metadatas: {
          id: {
            edit: {},
            list: { label: "id", searchable: true, sortable: true },
          },
          name: {
            edit: {
              label: "name",
              description: "",
              placeholder: "",
              visible: true,
              editable: true,
            },
            list: { label: "name", searchable: true, sortable: true },
          },
          type: {
            edit: {
              label: "type",
              description: "",
              placeholder: "",
              visible: true,
              editable: true,
            },
            list: { label: "type", searchable: true, sortable: true },
          },
          struuid: {
            edit: {
              label: "struuid",
              description: "",
              placeholder: "",
              visible: true,
              editable: true,
            },
            list: { label: "struuid", searchable: true, sortable: true },
          },
          setting: {
            edit: {
              label: "setting",
              description: "",
              placeholder: "",
              visible: true,
              editable: true,
            },
            list: { label: "setting", searchable: false, sortable: false },
          },
          createdAt: {
            edit: {
              label: "createdAt",
              description: "",
              placeholder: "",
              visible: false,
              editable: true,
            },
            list: { label: "createdAt", searchable: true, sortable: true },
          },
          updatedAt: {
            edit: {
              label: "updatedAt",
              description: "",
              placeholder: "",
              visible: false,
              editable: true,
            },
            list: { label: "updatedAt", searchable: true, sortable: true },
          },
          createdBy: {
            edit: {
              label: "createdBy",
              description: "",
              placeholder: "",
              visible: false,
              editable: true,
              mainField: "firstname",
            },
            list: { label: "createdBy", searchable: true, sortable: true },
          },
          updatedBy: {
            edit: {
              label: "updatedBy",
              description: "",
              placeholder: "",
              visible: false,
              editable: true,
              mainField: "firstname",
            },
            list: { label: "updatedBy", searchable: true, sortable: true },
          },
        },
        layouts: {
          edit: [
            [
              { name: "name", size: 6 },
              { name: "type", size: 6 },
            ],
            [{ name: "struuid", size: 6 }],
            [{ name: "setting", size: 12 }],
          ],
          list: ["id", "name", "type", "updatedAt"],
        },
      },
    });
    strapi.log.info("Initialized ListView: pabu.str");
  },
};

/**
 * doesStrTypeExist:
 * Returns true if str of this type (__component:-Value) does exist.
 * @returns {boolean}
 */
const doesStrTypeExist = (strs: Array<any>, strType: string) => {
  return strs.find(
    (strs) =>
      strs.setting && strs.setting[0] && strs.setting[0].__component === strType
  )
    ? true
    : false;
};